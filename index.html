<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
/>

<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>

<title>Chemical Reactions Graph Explorer</title>
<style>
    :root{
        --page-bg: #e8f4f8;
        --canvas-bg: #fef9f3;
        --frame: #d4e4f0;
        --main-bg: #fffef9;
        --panel-bg: #f7f4ff;
        --stripe-width: 1.25rem;
        --stripe-half: calc(var(--stripe-width) / 2);
        --transition: 300ms cubic-bezier(.2,.9,.3,1);
        --primary: #b8a8d9;
        --primary-hover: #9d89c7;
        --secondary: #a8d4e6;
        --accent: #f5c6cb;
        --text-primary: #4a4a6a;
        --text-secondary: #6b7280;
        --border: #e5d9f2;
    }

    /* Scrollbar width */
    ::-webkit-scrollbar {
        width: 0.25rem;       /* vertical scrollbar width */
        height: 0.25rem;      /* horizontal scrollbar height */
    }

    /* Track (background behind the thumb) */
    ::-webkit-scrollbar-track {
        background: transparent;  /* invisible track */
    }

    /* Thumb (the draggable part) */
    ::-webkit-scrollbar-thumb {
        background-color: rgba(0,0,0,0.25); /* semi-transparent dark thumb */
        border-radius: 1rem;               /* rounded ends */
    }

    /* Optional: hover effect */
    ::-webkit-scrollbar-thumb:hover {
        background-color: rgba(0,0,0,0.5);
    }

    html,body{
        height:100%;
        margin:0;
        font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: linear-gradient(135deg, var(--page-bg) 0%, #fef0f5 100%);
        display:flex;
        align-items:center;
        justify-content:center;
        padding:1.5rem;
        box-sizing:border-box;
        overflow: hidden;
    }

    .app-wrap{
        width: 95vw;
        height: 90vh;
        background: linear-gradient(135deg, var(--canvas-bg) 0%, #fff 100%);
        border: 1px solid var(--frame);
        border-radius: 1rem;
        box-shadow: 0 20px 60px rgba(140, 130, 190, 0.15);
        position: relative;
        overflow: hidden;
    }

    .main-window{
        position: absolute;
        inset: 0;
        background: var(--main-bg);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-primary);
        font-size: 1.125rem;
        z-index: 1;
        padding: 2rem;
    }

    .main-window-content {
        text-align: center;
        max-width: 500px;
    }

    .main-window-content strong {
        font-size: 1.5rem;
        color: var(--primary);
        display: block;
        margin-bottom: 0.75rem;
    }

    .main-window-content p {
        color: var(--text-secondary);
        font-size: 0.95rem;
        line-height: 1.6;
    }

    .side-panel{
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 25%;
        background: var(--panel-bg);
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(140, 130, 190, 0.2);
        z-index: 3;
        transform: translateX(-100%);
        transition: transform var(--transition);
        display: flex;
        flex-direction: column;
    }

    .toggle-stripe{
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: var(--stripe-width);
        display:flex;
        align-items:center;
        justify-content:center;
        cursor: pointer;
        user-select: none;
        z-index: 4;
        background: linear-gradient(180deg, rgba(184, 168, 217, 0.4), rgba(168, 212, 230, 0.3));
        backdrop-filter: blur(8px);
        border-radius: 0 0.5rem 0.5rem 0;
        box-shadow: 0 4px 12px rgba(140, 130, 190, 0.15);
        transition: left var(--transition), background var(--transition);
        border: none;
        outline: none;
    }

    .toggle-stripe:hover {
        background: linear-gradient(180deg, rgba(184, 168, 217, 0.6), rgba(168, 212, 230, 0.5));
    }

    .toggle-stripe svg{
        width: 0.875rem;
        height: 0.875rem;
        display:block;
        stroke: var(--text-primary);
        stroke-width: 2.5;
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        transition: transform var(--transition);
        transform-origin: center;
    }

    .app-wrap.open .side-panel{
        transform: translateX(0);
    }

    .app-wrap.open .toggle-stripe{
        left: calc(25%);
    }

    .app-wrap.open .toggle-stripe svg{
        transform: rotate(180deg);
    }

    .panel-content{
        font-size: 1rem;
        color: var(--text-primary);
        padding: 1.5rem;
        text-align: left;
        height: 100%;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .panel-content h3 {
        color: var(--primary);
        font-size: 0.95rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0 0 0.75rem 0;
    }

    .search-bar {
        display: flex;
        align-items: stretch;
        background: white;
        border: 2px solid var(--border);
        border-radius: 0.75rem;
        overflow: hidden;
        min-height: 3rem;
        flex-shrink: 0;
        box-shadow: 0 2px 8px rgba(184, 168, 217, 0.1);
        transition: border-color 0.2s, box-shadow 0.2s;
    }

    .search-bar:focus-within {
        border-color: var(--primary);
        box-shadow: 0 4px 12px rgba(184, 168, 217, 0.2);
    }

    .search-bar button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem;
        border: none;
        background: var(--primary);
        cursor: pointer;
        font-size: 0.9rem;
        min-width: 3rem;
        flex-shrink: 0;
        transition: background-color 0.2s;
        color: white;
    }

    .search-bar button:hover {
        background: var(--primary-hover);
    }

    .search-bar input {
        flex: 1;
        border: none;
        padding: 0.75rem 1rem;
        outline: none;
        font-size: 0.9rem;
        min-width: 0;
        background: transparent;
        color: var(--text-primary);
    }

    .search-bar input::placeholder {
        color: var(--text-secondary);
        opacity: 0.6;
    }

    .slider-container {
        display: flex;
        align-items: center;
        margin-top: 0.75rem;
        font-size: 0.85rem;
        color: var(--text-secondary);
    }

    .slider-container label {
        margin-right: 0.75rem;
        font-weight: 500;
    }

    .slider-container input[type="range"] {
        flex: 1;
        margin-right: 0.75rem;
        height: 6px;
        border-radius: 3px;
        background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
        outline: none;
        -webkit-appearance: none;
    }

    .slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(184, 168, 217, 0.3);
    }

    .slider-container input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(184, 168, 217, 0.3);
        border: none;
    }

    .slider-container span {
        min-width: 2rem;
        text-align: right;
        font-weight: 600;
        color: var(--primary);
    }

    .results {
        background: white;
        flex: 1;
        overflow-y: auto;
        border-radius: 0.75rem;
        box-shadow: inset 0 2px 8px rgba(184, 168, 217, 0.08);
        margin-top: 0.75rem;
        min-height: 0;
        padding: 0.5rem 0;
        border: 1px solid var(--border);
    }

    .result-item {
        display: flex;
        align-items: center;
        padding: 0.75rem;
        border-bottom: 1px solid #f3f0ff;
        font-size: 0.85rem;
        transition: background-color 0.2s;
        cursor: pointer;
    }

    .result-item:hover {
        background-color: #faf8ff;
    }

    .result-item:last-child {
        border-bottom: none;
    }

    .item-check {
        margin-right: 0.75rem;
        width: 1rem;
        height: 1rem;
        accent-color: var(--primary);
        cursor: pointer;
    }

    .item-icon {
        flex-shrink: 0;
        margin-right: 1rem;
        width: 5rem;
        height: 5rem;
        border: 2px solid var(--border);
        border-radius: 0.5rem;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(184, 168, 217, 0.1);
    }

    .item-icon svg {
        max-width: 100%;
        max-height: 100%;
    }

    .item-icon.loading {
        background: #faf8ff;
        color: var(--text-secondary);
        font-size: 0.7rem;
    }

    .item-info {
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex: 1;
        min-width: 0;
    }

    .item-name {
        font-weight: 600;
        margin-bottom: 0.35rem;
        word-break: break-word;
        color: var(--text-primary);
    }

    .item-extra {
        font-size: 0.75rem;
        color: var(--text-secondary);
    }

    .item-extra a {
        color: var(--primary);
        text-decoration: none;
        transition: color 0.2s;
    }

    .item-extra a:hover {
        color: var(--primary-hover);
        text-decoration: underline;
    }

    .load-more-btn {
        display: block;
        width: calc(100% - 1rem);
        padding: 0.75rem;
        margin: 0.5rem;
        background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        color: white;
        border: none;
        border-radius: 0.5rem;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 2px 8px rgba(184, 168, 217, 0.2);
    }

    .load-more-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(184, 168, 217, 0.3);
    }

    .load-more-btn:disabled {
        background: #e5d9f2;
        cursor: not-allowed;
        transform: none;
    }

    .no-results {
        text-align: center;
        padding: 2rem;
        color: var(--text-secondary);
        font-style: italic;
    }

    .loading-indicator {
        text-align: center;
        padding: 1.5rem;
        color: var(--text-secondary);
    }

    * { -webkit-tap-highlight-color: rgba(0,0,0,0); }

    .tooltip {
        position: absolute;
        background: white;
        border: 2px solid var(--border);
        padding: 0.75rem;
        border-radius: 0.75rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        text-align: center;
        z-index: 9999;
        box-shadow: 0 8px 24px rgba(184, 168, 217, 0.25);
        max-width: 200px;
    }

    .tooltip img {
        max-width: 120px;
        display: block;
        margin: 0 auto 0.5rem;
        border-radius: 0.5rem;
    }

    .tooltip-name {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 0.85rem;
    }

    .popup {
        position: fixed;
        background: white;
        border: 2px solid var(--border);
        border-radius: 1rem;
        box-shadow: 0 12px 40px rgba(184, 168, 217, 0.3);
        max-width: 90vw;
        max-height: 80vh;
        display: none;
        z-index: 1000;
        overflow: hidden;
    }

    .popup-header {
        background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        padding: 1rem 1.25rem;
        cursor: move;
        position: relative;
        user-select: none;
        color: white;
        font-weight: 600;
    }

    .popup-close {
        position: absolute;
        right: 1rem;
        top: 50%;
        transform: translateY(-50%);
        cursor: pointer;
        font-size: 1.5rem;
        color: white;
        width: 2rem;
        height: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0.5rem;
        transition: background 0.2s;
    }

    .popup-close:hover {
        background: rgba(255, 255, 255, 0.2);
    }

    .popup-content {
        padding: 1.25rem;
        overflow-y: auto;
        max-height: calc(80vh - 60px);
    }

    .popup-split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
    }

    .popup-direction {
        border: 2px solid var(--border);
        border-radius: 0.75rem;
        padding: 1rem;
        background: #faf8ff;
        min-width: 0;
        margin-bottom: 2.5rem;
    }

    .popup-direction h4 {
        margin: 0 0 0.75rem 0;
        color: var(--primary);
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .reaction-item {
        background: white;
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-bottom: 0.75rem;
        font-size: 0.8rem;
        position: relative;
    }

    .reaction-equation {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
        font-family: 'Courier New', monospace;
        max-height: 10rem;
        overflow-x: auto;
        display: flex;
        flex-wrap: nowrap;
        align-items: flex-start;
        justify-content: center;
    }

    .reaction-description {
        color: var(--text-secondary);
        font-size: 0.75rem;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 0.1rem solid #f3f0ff;
    }

    .reaction-svg-image {
        width: 5rem;
        height: 5rem;
        background-color: #f9f9f9;
        border: 0.1rem solid #eee;
        cursor: pointer;
    }

    .reaction-reactants, .reaction-products {
        display: flex;
        align-items: flex-start;
    }

    .reaction-participant {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0 0.75rem;
        max-width: 7rem;
        flex: 0 0 auto;
    }

    .reaction-participant-name {
        white-space: normal;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 5rem;
        text-align: center;
        margin-top: 0.5rem;
    }

    .reaction-sep {
        align-self: center;
        font-size: 2rem;
        color: var(--text-secondary);
        margin: 0.5rem;
    }

    .reaction-sep.reaction-sep-plus {
        font-size: 1.5rem;
    }

    .reaction-confidence {
        position: absolute;
        top: 0.3rem;       /* ~5px */
        right: 0.3rem;     /* ~5px */
        font-size: 0.625rem; /* ~10px */
        padding: 0.125rem 0.3125rem; /* 2px 5px */
        border-radius: 0.1875rem; /* ~3px */
        color: white;
        font-weight: bold;
    }

    .reaction-confidence-low { background-color: #FFB3BA; color: #333; }
    .reaction-confidence-medium { background-color: #FFEBA7; color: #333; }
    .reaction-confidence-high { background-color: #B5EAD7; color: #333; }

    .reaction-ord-label {
        position: absolute;
        top: 0.3rem;       /* ~5px */
        right: 0.3rem;     /* ~5px */
        width: 2rem;
        height: 2rem;
        padding: 0.125rem 0.3125rem; /* 2px 5px */
        border-radius: 0.1875rem; /* ~3px */
        font-weight: bold;
    }

    .reaction-participant-balanced {
        align-items: center;
        display: flex;
        justify-content: center;
        margin-left: 0.3rem;
        margin-right: 0.3rem;
    }

    .path-section {
        display: flex;
        flex-direction: column;
        margin-top: 1rem;
        max-height: 20rem;
    }

    #path-levels {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
    }

    .level {
        padding: 0.75rem;
        border: 2px solid var(--border);
        margin-bottom: 0.75rem;
        border-radius: 0.75rem;
        cursor: pointer;
        background: white;
        transition: all 0.2s;
    }

    .level:hover {
        border-color: var(--primary);
    }

    .level.selected {
        background: linear-gradient(135deg, #f3f0ff 0%, #faf8ff 100%);
        border-color: var(--primary);
        box-shadow: 0 2px 8px rgba(184, 168, 217, 0.2);
    }

    .level-title {
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: var(--primary);
        font-size: 0.85rem;
    }

    .level-items .result-item {
        cursor: default;
    }

    .remove-item {
        margin-left: auto;
        background: var(--accent);
        border: none;
        cursor: pointer;
        padding: 0.35rem 0.75rem;
        border-radius: 0.5rem;
        font-weight: 500;
        color: #8b4049;
        transition: all 0.2s;
    }

    .remove-item:hover {
        background: #f0a5af;
        transform: scale(1.05);
    }

    .catalog-section {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        margin-top: 1rem;
    }

    #loading-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(8px);
        z-index: 10;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        font-size: 1rem;
        color: var(--text-primary);
    }

    #loading-overlay i {
        font-size: 2.5rem;
        color: var(--primary);
        margin-bottom: 1rem;
    }

    #loading-overlay button {
        margin-top: 1.5rem;
        padding: 0.75rem 1.5rem;
        background: var(--accent);
        color: #8b4049;
        border: none;
        cursor: pointer;
        border-radius: 0.75rem;
        font-weight: 500;
        transition: all 0.2s;
    }

    #loading-overlay button:hover {
        background: #f0a5af;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(245, 198, 203, 0.3);
    }

    .compound-info {
        background: #faf8ff;
        border-radius: 0.75rem;
        padding: 1rem;
        margin-bottom: 1rem;
    }

    .compound-info-row {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem 0;
        border-bottom: 1px solid #f3f0ff;
        font-size: 0.85rem;
    }

    .compound-info-row:last-child {
        border-bottom: none;
    }

    .compound-info-label {
        font-weight: 600;
        color: var(--text-secondary);
        font-size: 0.85rem;
    }

    .compound-info-label.description {
        font-size: 1.2rem;
    }

    .compound-info-value {
        color: var(--text-primary);
        font-weight: 500;
    }

    .compound-structure {
        text-align: center;
        margin-bottom: 1rem;
    }

    .compound-structure img {
        max-width: 200px;
        border: 2px solid var(--border);
        border-radius: 0.75rem;
        padding: 1rem;
        background: white;
    }

    @media (max-height: 30rem) {
        .panel-content {
            padding: 0.75rem;
        }
        
        .search-bar {
            min-height: 2.5rem;
        }
    }

    @media (max-width: 30rem) {
        .app-wrap {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
        }
        
        html, body {
            padding: 0;
        }
        
        .side-panel {
            width: 80%;
        }
        
        .app-wrap.open .toggle-stripe {
            left: 80%;
        }

        .popup {
            width: 95vw;
        }

        .popup-split {
            grid-template-columns: 1fr;
        }
    }
</style>
</head>
<body>
    <div class="app-wrap" id="app" aria-live="polite">
        <div id="loading-overlay">
            <i class="fa fa-spinner fa-spin"></i>
            <p id="loading-message">Loading...</p>
            <button id="cancel-compute" style="display:none;">Cancel</button>
        </div>
        <div class="main-window" id="main" role="main" aria-label="Main content area">
            <div class="main-window-content">
                <strong>Chemical Reactions Graph Explorer</strong>
                <p>Search for chemical compounds using the side panel and build reaction pathways between source and target substances</p>
            </div>
        </div>

    <div class="side-panel" id="sidePanel" role="complementary" aria-hidden="true" aria-label="Side panel">
        <div class="panel-content">
            <div class="search-bar">
                <input type="text" id="search-input" placeholder="Search compounds..." />
                <button class="submit-btn" id="submit-button">
                    <i class="fa fa-check"></i>
                </button>
            </div>

            <div class="slider-container">
                <label for="k-slider">Top K:</label>
                <input type="range" id="k-slider" min="1" max="11" value="2">
                <span id="k-value">2</span>
            </div>
            <div class="slider-container">
                <label for="n-slider">Max Length N:</label>
                <input type="range" id="n-slider" min="1" max="10" value="3">
                <span id="n-value">3</span>
            </div>

            <div class="path-section">
                <h3>Path</h3>
                <div id="path-levels">
                    <div id="level1" class="level selected" data-level="1">
                        <div class="level-title">Sources</div>
                        <div class="level-items"></div>
                    </div>
                    <div id="level2" class="level" data-level="2">
                        <div class="level-title">Targets</div>
                        <div class="level-items"></div>
                    </div>
                </div>
            </div>

            <div class="catalog-section">
                <h3>Catalog</h3>
                <div class="results" id="results-container">
                    <div class="loading-indicator">
                        <i class="fa fa-spinner fa-spin"></i> Loading compounds...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <button class="toggle-stripe" id="toggle" aria-expanded="false" aria-controls="sidePanel" title="Toggle side panel">
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path d="M8 5l8 7-8 7"></path>
      </svg>
    </button>
  </div>

<script>
    let chemsData = [];
    let edgesData = [];
    let reactionsData = [];
    let fuse = null;
    let currentResults = [];
    let currentPage = 0;
    const RESULTS_PER_PAGE = 20;
    let selectedCIDs = new Set();
    let cidToCompound = new Map();
    let originalMainContent = '';
    let hoverTimeout;
    let selectedLevel = 1;
    let graph = new Map();
    let graph_reverse = new Map()
    let edgeToReactionID = new Map();
    let RIDToReaction = new Map();
    let currentEdges = new Set();
    let sourceNodes = new Set();
    let targetNodes = new Set();
    let secondaryNodes = new Set();
    let directedEdges = new Set();
    let backgroundCids;
    let cidToDescription = new Map();
    let ridToDescription = new Map();
    let commonnesSortedCids = []
    let cidToEdges = new Map();

    async function loadData(fileName) {
        try {
            const response = await fetch(fileName, { cache: "no-store" });
            const text = await response.text();

            let data = [];
            if (fileName.endsWith('.jsonl')) {
                data = text.split('\n').filter(line => line.trim() !== '');
                data = data.map(line => JSON.parse(line));
            }
            else if (fileName.endsWith('.json')) {
                data = JSON.parse(text);
            }

            return data;
        } catch(error) {
            console.error(`Error during fetching: ${fileName}; ${error}`);
            return [];
        }
    }

    async function initializeData() {
        showLoading('Loading data...');
        const resultsContainer = document.getElementById('results-container');
        originalMainContent = document.getElementById('main').innerHTML;
        
        try {
            chemsData = await loadData('data/chems/chems.jsonl');
            edgesData = await loadData('data/chems/chems_edges.jsonl');
            reactionsData = await loadData('data/reactions_parsed/reactions_parsed_balanced.jsonl');
            backgroundCids = await loadData('data/misc/background_cids.json');
            backgroundCids = new Set(backgroundCids.map(Number));
            commonnesSortedCids = await loadData('data/misc/commonness_sorted_cids.json');
            commonnesSortedCids = commonnesSortedCids.map(Number);
            
            let chemsDescriptionsLoaded = await loadData('data/chems/chems_descriptions.jsonl');
            chemsDescriptionsLoaded.forEach(entry => cidToDescription.set(entry.cid, entry.description));

            let reactionsDescriptionsLoaded = await loadData('data/reactions_details/reactions_details.jsonl');
            reactionsDescriptionsLoaded.forEach(entry => ridToDescription.set(entry.rid, entry.description));
            
            if (chemsData.length === 0) {
                resultsContainer.innerHTML = '<div class="no-results">No compound data available</div>';
                hideLoading();
                return;
            }
            
            edgesData.forEach(entry => {
                const edgeStr = `${entry.first}-${entry.second}`;
                edgeToReactionID.set(edgeStr, entry.reactions);
            });
            
            reactionsData.forEach(entry => {
                const rid = entry.rid;
                const copy = { ...entry };
                delete copy.rid;
                RIDToReaction.set(rid, copy);
            });

            chemsData.forEach(comp => {
                cidToCompound.set(comp.cid, comp);
            });

            edgesData.forEach(edge => {
                if (!graph.has(edge.first)) graph.set(edge.first, []);
                graph.get(edge.first).push(edge.second);

                if (!graph_reverse.has(edge.second)) graph_reverse.set(edge.second, []);
                graph_reverse.get(edge.second).push(edge.first);
            });

            for (const cid of commonnesSortedCids) cidToEdges.set(cid, []);
            edgesData.forEach(edge => {
                cidToEdges.get(edge.first).push(edge);
                cidToEdges.get(edge.second).push(edge);
            });

            const fuseOptions = {
                keys: ['cmpdname', 'synonyms'],
                threshold: 0.3,
                includeScore: true,
                minMatchCharLength: 2
            };
            
            fuse = new Fuse(chemsData, fuseOptions);
            
            chemsData = commonnesSortedCids.map(cid => cidToCompound.get(cid));

            displayResults(chemsData.slice(0, RESULTS_PER_PAGE));
            currentResults = chemsData;
            currentPage = 0;
            
            if (chemsData.length > RESULTS_PER_PAGE) {
                addLoadMoreButton();
            }
            
        } catch (error) {
            console.error('Error initializing data:', error);
            resultsContainer.innerHTML = '<div class="no-results">Error loading compound data</div>';
        }
        hideLoading();

        renderPathList();

        document.getElementById('level1').addEventListener('click', () => selectLevel(1));
        document.getElementById('level2').addEventListener('click', () => selectLevel(2));

        const kSlider = document.getElementById('k-slider');
        const kValue = document.getElementById('k-value');
        kSlider.addEventListener('input', () => {
            kValue.textContent = kSlider.value === '11' ? 'All' : kSlider.value;
        });

        const nSlider = document.getElementById('n-slider');
        const nValue = document.getElementById('n-value');
        nSlider.addEventListener('input', () => {
            nValue.textContent = nSlider.value;
        });
    }

    function returnToBlank() {
        selectedCIDs.clear();
        directedEdges.clear();
        document.getElementById('main').innerHTML = originalMainContent;
        refreshResults();
    }

    function selectLevel(level) {
        selectedLevel = level;
        document.getElementById('level1').classList.toggle('selected', level === 1);
        document.getElementById('level2').classList.toggle('selected', level === 2);
    }

    function renderPathList() {
        const level1Items = document.querySelector('#level1 .level-items');
        const level2Items = document.querySelector('#level2 .level-items');
        level1Items.innerHTML = '';
        level2Items.innerHTML = '';

        sourceNodes.forEach(cid => {
            const comp = cidToCompound.get(cid);
            if (comp) {
                const item = createPathItem(comp);
                level1Items.appendChild(item);
            }
        });

        targetNodes.forEach(cid => {
            const comp = cidToCompound.get(cid);
            if (comp) {
                const item = createPathItem(comp);
                level2Items.appendChild(item);
            }
        });
    }

    function createItemInfo(compound) {
        const itemInfo = document.createElement('div');
        itemInfo.className = 'item-info';
        
        const itemName = document.createElement('div');
        itemName.className = 'item-name';
        itemName.textContent = compound.cmpdname || 'Unknown compound';
        
        const itemExtra = document.createElement('div');
        itemExtra.className = 'item-extra';

        const cidLink = document.createElement('a');
        cidLink.href = `https://pubchem.ncbi.nlm.nih.gov/compound/${compound.cid}`;
        cidLink.textContent = `${compound.cid}`;
        cidLink.target = '_blank';
        const cidPrefix = document.createTextNode('CID: ');
        itemExtra.appendChild(cidPrefix);
        itemExtra.appendChild(cidLink);

        if (compound.wiki) {
            const wikiLink = document.createElement('a');
            wikiLink.href = compound.wiki;
            wikiLink.textContent = `${compound.wiki.split('/').at(-1).replace('_', ' ')}`;
            wikiLink.target = '_blank';
            
            const sep_wiki_prefix = document.createTextNode(' | Wiki: ');
            itemExtra.appendChild(sep_wiki_prefix);
            itemExtra.appendChild(wikiLink);
        }
        
        itemInfo.appendChild(itemName);
        itemInfo.appendChild(itemExtra);

        return itemInfo;
    }

    function createPathItem(compound) {
        const item = document.createElement('div');
        item.className = 'result-item';
        item.dataset.cid = compound.cid;

        const iconContainer = document.createElement('div');
        iconContainer.className = 'item-icon loading';
        iconContainer.textContent = 'Loading...';
        loadStructureSVG(compound.cid, iconContainer);

        const itemInfo = createItemInfo(compound);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-item';
        removeBtn.textContent = 'X';
        removeBtn.addEventListener('click', () => {
            if (selectedLevel === 1) {
                sourceNodes.delete(compound.cid);
            } else {
                targetNodes.delete(compound.cid);
            }
            renderPathList();
        });

        item.appendChild(iconContainer);
        item.appendChild(itemInfo);
        //item.appendChild(removeBtn);

        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (selectedLevel === 1) {
                sourceNodes.delete(compound.cid);
            } else {
                targetNodes.delete(compound.cid);
            }
            renderPathList();
        });

        return item;
    }

    function removeNode(cid, force = true) {
        let edges_to_del = []
        let secondary_parents = []
        let has_children = false;
        for(const edge of directedEdges) {
            let [a, b] = edge.split('-').map(Number);
            if(a === cid) {
                edges_to_del.push(edge);
                has_children = true;
            }
            else if(b === cid) {
                edges_to_del.push(edge);
                if(secondaryNodes.has(a))
                    secondary_parents.push(a);
            }
        }

        if(force || !has_children) {
            selectedCIDs.delete(cid);
            secondaryNodes.delete(cid);
            sourceNodes.delete(cid);
            targetNodes.delete(cid);

            for(const edge of edges_to_del)
                directedEdges.delete(edge);
            for(const cid of secondary_parents)
                removeNode(cid, false);
        }
    }

    function createResultItem(compound) {
        const item = document.createElement('div');
        item.className = 'result-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'item-check';
        checkbox.checked = selectedCIDs.has(compound.cid);
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                selectedCIDs.add(compound.cid);
                // Updates graph adding edges attached to this node
                updateGraph(compound.cid);
            } else {
                // Removes node with attached edges
                removeNode(compound.cid);
                // Updates graph without updating edges
                updateGraph();
            }
        });
        
        const iconContainer = document.createElement('div');
        iconContainer.className = 'item-icon loading';
        iconContainer.textContent = 'Loading...';
        iconContainer.dataset.cid = `${compound.cid}`;
        iconContainer.addEventListener('click', (e) => {
            const target = event.currentTarget;
            const cid = Number(target.dataset.cid);
            showCompoundInfoPopup(cid);
        });
        
        loadStructureSVG(compound.cid, iconContainer);
        
        const itemInfo = createItemInfo(compound);
        
        item.appendChild(checkbox);
        item.appendChild(iconContainer);
        item.appendChild(itemInfo);

        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (selectedLevel === 1) {
                sourceNodes.add(compound.cid);
            } else {
                targetNodes.add(compound.cid);
            }
            renderPathList();
        });
        
        return item;
    }

    function showCompoundInfoPopup(cid) {
        const name = cidToCompound.get(cid).cmpdname;
        showPopup('node', {id: cid, name: name});
    }

    function loadStructureSVG(cid, container) {
        const svgPath = `data/structures/${cid}.svg`;
        
        fetch(svgPath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.text();
            })
            .then(svgContent => {
                container.innerHTML = svgContent;
                container.classList.remove('loading');
            })
            .catch(error => {
                container.innerHTML = '<i class="fa fa-flask" style="color: #ccc;"></i>';
                container.classList.remove('loading');
            });
    }

    function displayResults(results) {
        const resultsContainer = document.getElementById('results-container');
        
        const existingBtn = resultsContainer.querySelector('.load-more-btn');
        if (existingBtn) {
            existingBtn.remove();
        }
        
        if (results.length === 0) {
            resultsContainer.innerHTML = '<div class="no-results">No compounds found</div>';
            return;
        }
        
        resultsContainer.innerHTML = '';
        results.forEach(compound => {
            const resultData = compound.item || compound;
            const resultItem = createResultItem(resultData);
            resultsContainer.appendChild(resultItem);
        });
    }

    function addLoadMoreButton() {
        const resultsContainer = document.getElementById('results-container');
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.className = 'load-more-btn';
        loadMoreBtn.textContent = 'Load More Results';
        loadMoreBtn.onclick = loadMoreResults;
        resultsContainer.appendChild(loadMoreBtn);
    }

    function loadMoreResults() {
        const endIndex = (currentPage + 1) * RESULTS_PER_PAGE + RESULTS_PER_PAGE;
        const nextResults = currentResults.slice(0, endIndex);
        
        if (nextResults.length > 0) {
            displayResults(nextResults);
            currentPage++;
            
            if (endIndex < currentResults.length) {
                addLoadMoreButton();
            }
        }
    }

    function refreshResults() {
        const endIndex = (currentPage + 1) * RESULTS_PER_PAGE + RESULTS_PER_PAGE;
        const nextResults = currentResults.slice(0, endIndex);
        
        if (nextResults.length > 0) {
            displayResults(nextResults);
            
            if (endIndex < currentResults.length) {
                addLoadMoreButton();
            }
        }
    }

    function performSearch(query) {
        const resultsContainer = document.getElementById('results-container');
        
        if (!query.trim()) {
            currentResults = chemsData;
            currentPage = 0;
            displayResults(chemsData.slice(0, RESULTS_PER_PAGE));
            
            if (chemsData.length > RESULTS_PER_PAGE) {
                addLoadMoreButton();
            }
            return;
        }
        
        if (!fuse) {
            resultsContainer.innerHTML = '<div class="no-results">Search not available</div>';
            return;
        }
        
        const searchResults = fuse.search(query);
        currentResults = searchResults;
        currentPage = 0;
        
        const firstPageResults = searchResults.slice(0, RESULTS_PER_PAGE);
        displayResults(firstPageResults);
        
        if (searchResults.length > RESULTS_PER_PAGE) {
            addLoadMoreButton();
        }
    }

    function bitCount(n) {
        n = n - ((n >> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
        return ((n + (n >> 4) & 0x0f0f0f0f) * 0x01010101) >> 24;
    }

    function computeTanimoto(fp1, fp2) {
        let andPop = 0;
        for (let i = 0; i < 32; i++) {
            const and = fp1.bits[i] & fp2.bits[i];
            andPop += bitCount(and);
        }
        const orPop = fp1.popcount + fp2.popcount - andPop;
        return orPop === 0 ? 1 : andPop / orPop;
    }

    function minH(node, ends) {
        let maxSim = 0;
        for (let end of ends) {
            const sim = computeTanimoto(cidToCompound.get(node).ECFP4_fp, cidToCompound.get(end).ECFP4_fp);
            if (sim > maxSim) maxSim = sim;
        }
        return 1 - maxSim;
    }

    class PriorityQueue {
        constructor(comparator = (a, b) => a - b) {
            this._heap = [];
            this._comparator = comparator;
        }
        size() {
            return this._heap.length;
        }
        peek() {
            return this._heap[0];
        }
        push(value) {
            this._heap.push(value);
            this._siftUp();
            return this.size();
        }
        pop() {
            const poppedValue = this.peek();
            const bottom = this.size() - 1;
            if (bottom > 0) {
                this._swap(0, bottom);
            }
            this._heap.pop();
            this._siftDown();
            return poppedValue;
        }
        _greater(i, j) {
            return this._comparator(this._heap[i], this._heap[j]) < 0;
        }
        _swap(i, j) {
            [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
        }
        _siftUp() {
            let node = this.size() - 1;
            while (node > 0 && this._greater(node, Math.floor((node - 1) / 2))) {
                this._swap(node, Math.floor((node - 1) / 2));
                node = Math.floor((node - 1) / 2);
            }
        }
        _siftDown() {
            let node = 0;
            while (
                (2 * node + 1 < this.size() && this._greater(2 * node + 1, node)) ||
                (2 * node + 2 < this.size() && this._greater(2 * node + 2, node))
            ) {
                let maxChild = (2 * node + 2 < this.size() && this._greater(2 * node + 2, 2 * node + 1)) ? 2 * node + 2 : 2 * node + 1;
                this._swap(node, maxChild);
                node = maxChild;
            }
        }
    }

    function findKShortestPathsWithSources(sources, targets, k, maxLen) {
        // Finds paths from targets to sources using reversed graph and then reverses paths

        const sourceSet = new Set(sources);
        const pq = new PriorityQueue((a, b) => a.f - b.f);
        const paths = [];

        for (let target of targets) {
            const h = minH(target, sources);
            pq.push({f: 0 + h, cost: 0, node: target, path: [target]});
        }

        while (pq.size() > 0 && paths.length < k) {
            const current = pq.pop();
            const {cost, node, path} = current;

            if (cost > maxLen) continue;

            if (sourceSet.has(node) && cost > 0) {
                paths.push({path, length: cost});
                continue;
            }

            for (let neigh of graph_reverse.get(node) || []) {
                if (path.includes(neigh)) continue;
                if (backgroundCids.has(neigh) && !sourceSet.has(neigh)) continue;
                const newCost = cost + 1;
                const h = minH(neigh, sources);
                const newF = newCost + h;
                const newPath = [...path, neigh];
                pq.push({f: newF, cost: newCost, node: neigh, path: newPath});
            }
        }

        paths.forEach(path => { path.path.reverse() })

        return paths;
    }

    function findKShortestPathsNoSources(targets, k, maxLen) {
        // Finds paths from targets to compounds with complexity <= complexityThr using complexity difference as distance
        
        const queue = []
        const paths = [];

        const complexityThr = 10
        
        const hMetrics = node => {
            const nodeComplexity = cidToCompound.get(node).complexity;
            return nodeComplexity > complexityThr ? nodeComplexity - complexityThr : 0;
        }

        for (let target of targets) {
            const h = hMetrics(target);
            queue.push({cost: 0, node: target, path: [target]});
        }

        while (queue.length > 0 && paths.length < k) {
            const current = queue.shift();
            const {cost, node, path} = current;
            const currentH = hMetrics(node);

            if (cost > maxLen) continue;
            
            if (cost > 0)
                paths.push({path, length: cost});
            if (paths.length > k)
                paths.shift();

            for (let neigh of graph_reverse.get(node) || []) {
                const h = hMetrics(neigh);
                if (h > currentH || path.includes(neigh) || backgroundCids.has(neigh)) continue;
                const newCost = cost + 1;
                const newPath = [...path, neigh];
                queue.push({cost: newCost, node: neigh, path: newPath});
            }
        }

        paths.forEach(path => { path.path.reverse() });

        return paths;
    }

    function getProcessedLinks() {
        const links = [];
        const processed = new Set();
        for (let edge of directedEdges) {
            if (processed.has(edge)) continue;
            const [a, b] = edge.split('-').map(Number);

            const reverse = `${b}-${a}`;
            let type = null;
            if (directedEdges.has(reverse)) {
                type = 'bi';
                processed.add(reverse);
            } else {
                type = 'directed';
            }

            const secondary = secondaryNodes.has(a) || secondaryNodes.has(b);
            links.push({source: a, target: b, type, secondary});
            processed.add(edge);
        }
        return links;
    }

    function handleSubmit() {
        secondaryNodes = new Set();
        directedEdges = new Set();

        const sources = Array.from(sourceNodes);
        const targets = Array.from(targetNodes);
        if (targets.length === 0) {
            if (sources.length !== 0) {
                alert('Please add at least one target substance.');
                return;
            }
            returnToBlank();
            return;
        }

        const sourcesSelected = sources.length > 0;

        let k = parseInt(document.getElementById('k-slider').value);
        if (k === 11) k = Infinity;
        const n = parseInt(document.getElementById('n-slider').value);

        showLoading('Computing paths...', true);

        setTimeout(() => {
            const allPaths = sourcesSelected ? findKShortestPathsWithSources(sources, targets, k, n) : findKShortestPathsNoSources(targets, k, n);
            selectedCIDs.clear();

            allPaths.forEach(({path}) => path.forEach(node => selectedCIDs.add(node)));
            allPaths.forEach(({path}) => {
                for (let i = 0; i < path.length - 1; i++) {
                    const edgeStr = `${path[i]}-${path[i+1]}`;
                    const reactionIDs = edgeToReactionID.get(edgeStr);
                    for(const rid of reactionIDs) {
                        const reaction = RIDToReaction.get(rid);
                        for(const reagent of reaction.reagents) {
                            const cid = reagent.cid;
                            directedEdges.add(`${cid}-${path[i+1]}`);
                            if(!selectedCIDs.has(cid)) {
                                if(sourcesSelected)
                                    secondaryNodes.add(cid);
                                selectedCIDs.add(cid);
                            }
                        }
                    }
                }
            });
            
            updateGraph();
            hideLoading();
        }, 0);
    }

    function updateGraph(cid = null) {
        const selectedArray = Array.from(selectedCIDs);
        if (selectedArray.length === 0) {
            document.getElementById('main').innerHTML = originalMainContent;
            return;
        }

        if(cid !== null) {
            selectedCIDs.forEach(selected_cid => {
                cidToEdges.get(selected_cid)
                    .filter(edge => 
                        selectedCIDs.has(edge.first) && selectedCIDs.has(edge.second) &&
                        (edge.first === cid || edge.second === cid) &&
                        !secondaryNodes.has(edge.first) && !secondaryNodes.has(edge.second))
                    .forEach(edge => directedEdges.add(`${edge.first}-${edge.second}`));
            });
        }

        const nodes = selectedArray.map(node => {
            const comp = cidToCompound.get(node);
            return {
                id: node,
                name: comp ? comp.cmpdname : 'Unknown',
                organic: comp ? comp.organic : false,
                secondary: secondaryNodes.has(node)
            };
        });

        const links = getProcessedLinks();

        refreshResults();
        renderGraph(nodes, links);
    }

    function renderGraph(nodes, links) {
        const main = d3.select("#main");
        main.html("");

        const width = main.node().clientWidth;
        const height = main.node().clientHeight;

        const svg = main.append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .style("max-width", "100%")
            .style("height", "auto");

        const defs = svg.append("defs");

        defs.append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -3 10 6")
            .attr("refX", "10")
            .attr("refY", "0")
            .attr("markerWidth", "6")
            .attr("markerHeight", "6")
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-3L10,0L0,3")
            .attr("fill", "#b8a8d9");

        defs.append("marker")
            .attr("id", "arrow-start")
            .attr("viewBox", "0 -3 10 6")
            .attr("refX", "10")
            .attr("refY", "0")
            .attr("markerWidth", "6")
            .attr("markerHeight", "6")
            .attr("orient", "auto-start-reverse")
            .append("path")
            .attr("d", "M0,-3L10,0L0,3")
            .attr("fill", "#b8a8d9");

        const g = svg.append("g");

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const link = g.append("g")
            .attr("stroke", "#b8a8d9")
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("stroke-width", 2)
            .attr("marker-end", d => "url(#arrow)")
            .attr("marker-start", d => d.type === 'bi' ? "url(#arrow-start)" : null)
            .attr("stroke-opacity", d => d.secondary ? 0.3 : 0.7)
            .style("cursor", "pointer")
            .on("mouseover", function(event, d) {
                d3.select(this).attr("stroke-width", 4).attr("stroke", "#9d89c7");
            })
            .on("mouseout", function(event, d) {
                d3.select(this).attr("stroke-width", 2).attr("stroke", "#b8a8d9");
            })
            .on("click", function(event, d) {
                showPopup('edge', d);
            });
        
        const secondaryOpacity = 0.3;
        const defaultOpacity = 1.0;

        const nodeGroups = g.append("g")
            .selectAll("g")
            .data(nodes)
            .join("g")
            .attr("opacity", d => secondaryNodes.has(d.id) ? secondaryOpacity : defaultOpacity)
            .style("cursor", "pointer")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            )
            .on("mouseover", function(event, d) {
                d3
                .select(this)
                .attr('opacity', defaultOpacity)
                .select("circle, rect, polygon")
                .attr("r", 8).attr("width", 16)
                .attr("height", 16)
                .attr("points", "0,-8 8,8 -8,8");
                hoverTimeout = setTimeout(() => {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`<img src="data/structures/${d.id}.svg" alt="${d.name}"><div class="tooltip-name">${d.name}</div>`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                }, 500);
            })
            .on("mousemove", function(event, d) {
                tooltip.style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function(event, d) {
                d3
                .select(this)
                .attr('opacity', d => secondaryNodes.has(d.id) ? secondaryOpacity : defaultOpacity)
                .select("circle, rect, polygon")
                .attr("r", 5)
                .attr("width", 10)
                .attr("height", 10)
                .attr("points", "0,-5 5,5 -5,5");
                clearTimeout(hoverTimeout);
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
            .on("click", function(event, d) {
                showPopup('node', d);
            });

        nodeGroups.each(function(d) {
            const sel = d3.select(this);
            const color = d.organic ? "#7bc67b" : "#6ba3d6";
            if (sourceNodes.has(d.id)) {
                sel.append("rect")
                    .attr("x", -5)
                    .attr("y", -5)
                    .attr("width", 10)
                    .attr("height", 10)
                    .attr("fill", color);
            } else if (targetNodes.has(d.id)) {
                sel.append("polygon")
                    .attr("points", "0,-5 5,5 -5,5")
                    .attr("fill", color);
            } else {
                sel.append("circle")
                    .attr("r", 5)
                    .attr("fill", color);
            }
        });

        const labels = nodeGroups.append("text")
            .text(d => d.name)
            .attr("font-size", 10)
            .attr("text-anchor", "middle")
            .attr("dy", 20)
            .attr("fill", "#4a4a6a")
            .attr("font-weight", 500);

        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        simulation.on("tick", () => {
            link
                .attr("x1", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    const normX = dx / dr;
                    const sourcePadding = d.type === 'bi' ? 8 : 0;
                    return d.source.x + (normX * sourcePadding);
                })
                .attr("y1", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    const normY = dy / dr;
                    const sourcePadding = d.type === 'bi' ? 8 : 0;
                    return d.source.y + (normY * sourcePadding);
                })
                .attr("x2", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    const normX = dx / dr;
                    const targetPadding = (d.type === 'directed' || d.type === 'bi') ? 8 : 0;
                    return d.target.x - (normX * targetPadding);
                })
                .attr("y2", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    const normY = dy / dr;
                    const targetPadding = (d.type === 'directed' || d.type === 'bi') ? 8 : 0;
                    return d.target.y - (normY * targetPadding);
                });

            nodeGroups
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
        });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        const zoom = d3.zoom()
            .scaleExtent([0.5, 4])
            .on("zoom", ({transform}) => {
                g.attr("transform", transform);
            });

        svg.call(zoom);
    }

    function showPopup(type, data) {
        // Create new popup container dynamically
        const popup = document.createElement('div');
        popup.classList.add('popup', `popup-${type}`);

        popup.innerHTML = `
            <div class="popup-header">
                <span id="popup-title">Title</span>
                <span class="popup-close" onclick="this.closest('.popup').remove()"></span>
            </div>
            <div class="popup-content" id="popup-content">
            Content
            </div>
        `;

        document.body.appendChild(popup);

        const title = popup.querySelector('#popup-title');
        const content = popup.querySelector('#popup-content');

        if (type === 'node') {
            const compound = cidToCompound.get(data.id);
            title.textContent = compound ? compound.cmpdname : 'Node Info';
            
            let html = '<div class="compound-structure">';
            html += `<img src="data/structures/${data.id}.svg" alt="${compound.cmpdname}" onerror="this.style.display='none'">`;
            html += '</div>';
            
            html += '<div class="compound-info">';
            html += '<div class="compound-info-row">';
            html += '<span class="compound-info-label">CID:</span>';
            html += `<span class="compound-info-value"><a href="https://pubchem.ncbi.nlm.nih.gov/compound/${data.id}" target="_blank">${data.id}</a></span>`;
            html += '</div>';
            
            if (compound && compound.wiki) {
                html += '<div class="compound-info-row">';
                html += '<span class="compound-info-label">Wikipedia:</span>';
                html += `<span class="compound-info-value"><a href="${compound.wiki}" target="_blank">${compound.wiki.split('/').at(-1).replace('_', ' ')}</a></span>`;
                html += '</div>';
            }
            
            html += '<div class="compound-info-row">';
            html += '<span class="compound-info-label">Type:</span>';
            html += `<span class="compound-info-value">${compound.organic ? 'Organic' : 'Inorganic'}</span>`;
            html += '</div>';

            html += '</div>';
            
            const description = cidToDescription.get(data.id);
            if (description) {
                html += '<div class="compound-info">';
                html += '<span class="compound-info-label description">Description:</span>';
                description_html = '<p>' + description.split('\n\n').join('</p><p>') + '</p>';
                html += `<span class="compound-info-value">${description_html}</span>`;
                html += '</div>';
                html += '</div>';
            }
            
            content.innerHTML = html;
        } else if (type === 'edge') {
            const sourceId = typeof data.source === 'object' ? data.source.id : data.source;
            const targetId = typeof data.target === 'object' ? data.target.id : data.target;
            const sourceComp = cidToCompound.get(sourceId);
            const targetComp = cidToCompound.get(targetId);
            const sourceName = sourceComp ? sourceComp.cmpdname : sourceId;
            const targetName = targetComp ? targetComp.cmpdname : targetId;
            
            title.textContent = 'Reactions';
            
            const edgeStr = `${sourceId}-${targetId}`;
            const reverseEdgeStr = `${targetId}-${sourceId}`;
            const forwardReactionIDs = edgeToReactionID.get(edgeStr) || [];
            const reverseReactionIDs = data.type === 'bi' ? (edgeToReactionID.get(reverseEdgeStr) || []) : [];
            
            let html = '';

            const generateReactionParticipants = (participants, balanced) => {
                let reactants_htmls = [];
                for (const entry of participants) {
                    const cid = entry.cid;
                    const compound = cidToCompound.get(cid);
                    const name = compound.cmpdname;
                    let curr_html = ""
                    curr_html += `<div class="reaction-participant">`;
                    curr_html += `<img class="reaction-svg-image" src="data/structures/${cid}.svg" alt="${name}" data-cid="${cid}">`;
                    curr_html += `<span class="reaction-participant-name" title="${name}">${name}</span>`;
                    curr_html += '</div>';
                    
                    if (balanced) {
                        const coeff = entry.coeff;
                        curr_html = `<div class="reaction-participant-balanced"><span class="reaction-participant-coeff">${coeff}</span>${curr_html}</div>`
                    }
                    reactants_htmls.push(curr_html)
                }
                return reactants_htmls.join('<span class="reaction-sep reaction-sep-plus">+</span>')
            };

            const generateReactionItem = (rid) => {
                const getConfidenceClass = (confidence) => {
                    const classPrefix = 'reaction-confidence-'
                    if (confidence < 0.5)
                        return classPrefix + 'low';
                    else if (confidence < 0.7)
                        return classPrefix + 'medium';
                    else
                        return classPrefix + 'high';
                };

                item_html = "";
                const reaction = RIDToReaction.get(rid);
                if (reaction) {
                    const balanced = reaction.balanced;
                    console.log(balanced)
                    item_html += '<div class="reaction-item">';
                    item_html += `<div class="reaction-equation">`;
                    item_html += generateReactionParticipants(reaction.reagents, balanced);
                    item_html += '<span class="reaction-sep reaction-sep-arrow"></span>';
                    item_html += generateReactionParticipants(reaction.products, balanced);
                    item_html += '</div>';

                    const description = ridToDescription.get(rid);
                    if (description) {
                        item_html += '<div class="reaction-description">';
                        item_html += '<strong>Description:</strong> ';
                        item_html += description;
                        item_html += '</div>';
                    }

                    const confidence = reaction.confidence;
                    if (confidence) {
                        const confidenceClass = getConfidenceClass(confidence);
                        item_html += `<span class="reaction-confidence ${confidenceClass}" title="This reaction is generated automatically and this is its validation score.">${confidence.toFixed(2)}</span>`;
                    } else if (reaction.source == 'ord') {
                        item_html += `<img src="data/assets/ord.svg" class="reaction-ord-label" title="Sourced from Open Reaction Database">`
                    }

                    item_html += '</div>';
                }

                return item_html;
            };

            const generateReactionList = (rids) => {
                let reactionsHtml = "";
                if (rids.length > 0) {
                    rids.forEach(rid => {
                        reactionsHtml += generateReactionItem(rid);
                    });
                } else {
                    reactionsHtml += '<div class="reaction-item">No reactions found</div>';
                }

                return reactionsHtml;
            };
            
            if (data.type === 'bi') {
                html += '<div class="popup-split">';
                
                html += '<div class="popup-direction">';
                html += `<h4> ${sourceName}  ${targetName}</h4>`;
                html += generateReactionList(forwardReactionIDs);
                html += '</div>';
                
                html += '<div class="popup-direction">';
                html += `<h4> ${targetName}  ${sourceName}</h4>`;
                html += generateReactionList(reverseReactionIDs);
                html += '</div>';
                
                html += '</div>';
            } else {
                html += '<div class="popup-direction">';
                html += `<h4> ${sourceName}  ${targetName}</h4>`;
                html += generateReactionList(forwardReactionIDs);
                html += '</div>';
            }
            
            content.innerHTML = html;
        }

        popup.style.display = 'block';
        popup.style.position = 'absolute';
        popup.style.visibility = 'visible';
        popup.style.opacity = '1';

        const rect = popup.getBoundingClientRect();
        popup.style.left = (window.innerWidth / 2 - rect.width / 2) + 'px';
        popup.style.top = (window.innerHeight / 2 - rect.height / 2) + 'px';

        makeDraggable(popup);

        document.querySelectorAll('.reaction-svg-image').forEach(el => {
            el.onclick = () => {
                const cid = Number(el.dataset.cid);
                showCompoundInfoPopup(cid);
            };
        });
    }

    function makeDraggable(element) {
        const header = element.querySelector('.popup-header');
        header.addEventListener('mousedown', function(e) {
            e.preventDefault();
            let shiftX = e.clientX - element.getBoundingClientRect().left;
            let shiftY = e.clientY - element.getBoundingClientRect().top;

            function moveAt(pageX, pageY) {
                element.style.left = pageX - shiftX + 'px';
                element.style.top = pageY - shiftY + 'px';
            }

            function onMouseMove(e) {
                moveAt(e.pageX, e.pageY);
            }

            document.addEventListener('mousemove', onMouseMove);

            document.addEventListener('mouseup', function() {
                document.removeEventListener('mousemove', onMouseMove);
            }, {once: true});
        });
    }

    function showLoading(message, showCancel = false) {
        const overlay = document.getElementById('loading-overlay');
        document.getElementById('loading-message').textContent = message;
        document.getElementById('cancel-compute').style.display = showCancel ? 'block' : 'none';
        overlay.style.display = 'flex';
    }

    function hideLoading() {
        document.getElementById('loading-overlay').style.display = 'none';
    }

    (function(){
        const app = document.getElementById('app');
        const toggle = document.getElementById('toggle');
        const sidePanel = document.getElementById('sidePanel');

        let isOpen = false;

        function setOpen(open){
            if(open){
                app.classList.add('open');
                toggle.setAttribute('aria-expanded','true');
                sidePanel.setAttribute('aria-hidden','false');
            } else {
                app.classList.remove('open');
                toggle.setAttribute('aria-expanded','false');
                sidePanel.setAttribute('aria-hidden','true');
            }
        }

        setOpen(isOpen);

        toggle.addEventListener('click', function(){
            isOpen = !isOpen;
            setOpen(isOpen);
        });

        document.addEventListener('keydown', function(e){
            if(e.key === 'Escape' && isOpen){
                isOpen = false;
                setOpen(isOpen);
                toggle.focus();
            }
        });
    })();

    (function(){
        const submitButton = document.getElementById('submit-button');
        const searchInput = document.getElementById('search-input');
        const cancelCompute = document.getElementById('cancel-compute');
        
        let searchTimeout;

        function handleSearch() {
            const query = searchInput.value;
            performSearch(query);
        }

        submitButton.addEventListener('click', handleSubmit);

        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                handleSearch();
            }
        });

        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                handleSearch();
            }, 300);
        });

        cancelCompute.addEventListener('click', hideLoading);
    })();

    document.addEventListener('DOMContentLoaded', initializeData);
</script>
</body>
</html>